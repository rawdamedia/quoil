<!DOCTYPE html>
<html>
  <head>
    <title>Elixir.Quoil.ArgsProcessor</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/source.css" type="text/css" media="screen" charset="utf-8" />
    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
  </head>

  <body>
    <div id="content">
      <h1>Elixir.Quoil.ArgsProcessor Coverage Source Code</h1>

      <table class="source">
        <thead>
          <tr>
            <th>Line Number</th><th>Covered Lines</th><th>Source Code</th>
          </tr>
        </thead>
        <tbody>
          <tr class="source"><td class="num"> 1</td> <td class="num"> </td> 
<td class="elixir">

	<a name="#Elixir.Quoil.ArgsProcessor"></a>

<pre class="irrelevant"> defmodule Quoil.ArgsProcessor do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 2</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   @moduledoc """
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 3</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   ###Processes the command-line arguments passed to the quoil app
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 4</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 5</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   *argv* can be *-h* or *--help*, which returns *:help*, ignoring any other switches that may have been specified.  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 6</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 7</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   Optional switches can be specified:  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 8</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *\-\-interval* or *-i* to set the interval in seconds between pings
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 9</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *\-\-number* or *-n* to set the number of pings in each run  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 10</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *\-\-repeat* or *-r* to repeat an additional specified number of times (defaults to *nil*)  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 11</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *\-\-wait* or *-w* to set the number of minutes before repeating (ignored unless *\-\-repeat* also specified)  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 12</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   Need to specify the *ip_to_ping* as an IP address or URL.  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 13</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   If *log_file_name* is not specified, it defaults to *:std_out*  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 14</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 15</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   Return a tuple of `{ip_to_ping, %{switches}, log_file_name}`, or `:help` if help was requested or error in supplied switches.
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 16</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   """
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 17</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 18</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   @default_interval Application.get_env(:quoil, :interval_between_pings_sec)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 19</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   @default_number Application.get_env(:quoil, :number_of_pings)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 20</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   @default_wait Application.get_env(:quoil, :wait_period_min)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 21</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 22</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 23</td> <td class="num"> </td> 
<td class="elixir">

	<a name="#Elixir.Quoil.ArgsProcessor.parse_args.1"></a>

<pre class="irrelevant">   def parse_args(argv) do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 24</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     # IO.puts argv
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 25</td> <td class="num"> 23</td> 
<td class="elixir">

<pre class="covered">     parse = OptionParser.parse(argv,
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 26</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">       strict: [help: :boolean, interval: :integer, number: :integer, repeat: :integer, wait: :integer],
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 27</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">       aliases:  [h: :help, i: :interval, n: :number, r: :repeat, w: :wait])
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 28</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     # Logger.info "Parsed arguments: #{Kernel.inspect(parse)}"
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 29</td> <td class="num"> 23</td> 
<td class="elixir">

<pre class="covered">     case parse do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 30</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">       { _, _, errors} when errors != [] -&gt; :help
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 31</td> <td class="num"> 15</td> 
<td class="elixir">

<pre class="covered">       { switches, arguments, _ } -&gt; process_switches(switches[:help], Enum.into(switches, %{}), arguments)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 32</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">       _ -&gt; :error
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 33</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 34</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 35</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 36</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 37</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   @doc"""
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 38</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   Makes sure that if --help|-h is included anywhere then all other options are ignored and help is printed.  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 39</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   Returns a data tuple of `{*ip_to_ping*, *switches*, *log_file_name*}` where:  
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 40</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *ip_to_ping* is a String of either the URL or IP to be supplied to the `ping` command.
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 41</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *switches* is a map containing all the values (default or supplied) for the options to be passed to the ping command.
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 42</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   - *log_file_name* is **:std_out** or the path to the file to save the results to. 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 43</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   """
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 44</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   def process_switches(true, _, _) do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 45</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     :help
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 46</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 47</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   def process_switches(nil, %{}, []) do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 48</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     :help
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 49</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 50</td> <td class="num"> </td> 
<td class="elixir">

	<a name="#Elixir.Quoil.ArgsProcessor.process_switches.3"></a>

<pre class="irrelevant">   def process_switches(nil, switches, [ip_to_ping | log_file_name]) do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 51</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     # in the future can implement logging to multiple destinations
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 52</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     switches = Map.put_new(switches, :interval, @default_interval)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 53</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     switches = Map.put_new(switches, :number, @default_number)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 54</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     switches = Map.put_new(switches, :wait, @default_wait)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 55</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 56</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     # make sure that only positive integers are passed
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 57</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     switches = Enum.reduce([:interval, :number, :repeat, :wait], switches, 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 58</td> <td class="num"> 40</td> 
<td class="elixir">

<pre class="covered">                 fn (key, map) -&gt; Map.update(map, key, nil, fn(val)-&gt;Kernel.abs(val) end) end)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 59</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 60</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     if log_file_name == [] do
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 61</td> <td class="num"> 2</td> 
<td class="elixir">

<pre class="covered">       log_file_name = :std_out
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 62</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     else
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 63</td> <td class="num"> 8</td> 
<td class="elixir">

<pre class="covered">       log_file_name = List.first(log_file_name)
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 64</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">       # NB this will cause all non-switches after log_file_name to be ignored
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 65</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">     end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 66</td> <td class="num"> 10</td> 
<td class="elixir">

<pre class="covered">     {ip_to_ping, switches, log_file_name}
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 67</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant">   end
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 68</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> 
</pre>
</td>
</tr> 
<tr class="source"><td class="num"> 69</td> <td class="num"> </td> 
<td class="elixir">

<pre class="irrelevant"> end</pre>
</td>
</tr> 

        </tbody>
      </table>

    
    <!-- ein paar Ideen: 
    	* Tabelle explizit machen mit sehr kleinen Größen
    	* spezielle Formatierungen (Keywords, ..) mit spans machen.
    	* Beispiel: https://coveralls.io/files/233825459
    -->

    </div>
  </body>
</html>
